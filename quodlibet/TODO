Translations
------------
Also, comments for translators where appropriate.

Song rating system
------------------
Don't tell anyone, but the ~#rating key exists already. It just needs UI.

UI Tweaking
-----------
Continue HIGification, handle very long titles/filenames better.

Remember browser information
----------------------------
Browsers need a way to properly save and reinitialize themselves. Also,
remember song list sort order.

GStreamer backend
-----------------
Experiment with a GStreamer backend. This is not very interesting from
a format perspective (yet), but it might let us avoid threading problems.

Support for more audio formats
------------------------------
Monkey's Audio is the most requested (i.e., everything else requested
has been implemented), but MA is not a freely licensed codec. Maybe
we should support WAV? Other possibilities are forms of M4A/AAC,
RM, WMA, if free libraries exist to read from them.

Covers from Muine, RB
---------------------
Muine uses a pixmap serialization function to save to a BDB database.
This function is not available directly from PyGTK. If it was, this
would be easy.

RB's album cover patch is immature, but so far just stores JPGs
in ~/.gnome2/rhythmbox.

Browser modes
-------------
A Muine-style album browser.
A Jukebox mode (requires 'just browser, no player' windows).

Album cover download
--------------------
Amazon has a ToS I can't agree to, but a Google image search for the
album name (or especially label ID) seems to be effective.

Unit tests
----------
Keep testing new functions, keep writing new tests for old functions
when bugs are found.

PMP Interfacing
---------------
The current PMP system is designed for small devices that manage playlists.
Large (multi-GB) ones have different needs, and instead should use (partial)
mirror of the library.

IÃ±igo suggested using a "shared" flagin the song metadata, which would
(on the user's request) copy the filesystem structure to the device;
the device would be tracked with HAL/DBUS.

Another way would be to store an "alternate filenames" list with each
song. This would let you use multiple devices/filesystems at once, but
I don't think that's a common enough use case to justify the complexity.

HAL/DBUS
--------
We could use the above HAL/DBUS part to know when a device is
plugged in, and trigger a library refresh if it's in our scan directories
or masked list. This is a good idea even without the above stuff.

Related we should whip our song-update callbacks into shape. The less
entry points the better.

New keys
--------
Bitrate/quality.
File size?

IRC Dumps
---------
(mu) hmm. is it a bug that if you, vorbisgain, don't refresh, edit your tags
+and save the gained files, you lose the vorbisgain?
(piman) good question.
(piman) do we need a warning dialog if the mtime is wrong?

Others
------
RPM spec/package, Gentoo ebuild, whatever.
A real manual, not just a man page.
(Python-based) plugin system for the song list context menu.
